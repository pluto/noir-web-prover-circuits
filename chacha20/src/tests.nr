use crate::chacha20::{chacha20_block, quarter_round};
use crate::setup::{data_hasher, polynomial_digest, SetupState};
use crate::setup::PADDING_VALUE;

#[test]
fn test_chacha20_quarter_round_example() {
    // Example from RFC 7539
    // 2.1.1.  Test Vector for the ChaCha Quarter Round
    let a = 0x11111111;
    let b = 0x01020304;
    let c = 0x9b8d6f43;
    let d = 0x01234567;

    let (a_out, b_out, c_out, d_out) = quarter_round(a, b, c, d);
    // Expected values from the example
    assert_eq(a_out, 0xea2a92f4);
    assert_eq(b_out, 0xcb1cf8ce);
    assert_eq(c_out, 0x4581472e);
    assert_eq(d_out, 0x5881c4bb);
}

#[test]
fn test_chacha20_quarter_round_zero_input() {
    let (a_out, b_out, c_out, d_out) = quarter_round(0, 0, 0, 0);
    // All zeros should result in all zeros
    assert_eq(a_out, 0);
    assert_eq(b_out, 0);
    assert_eq(c_out, 0);
    assert_eq(d_out, 0);
}

#[test]
fn test_chacha20_block_function() {
    // https://www.rfc-editor.org/rfc/rfc7539.html#section-2.3.2
    let key = [
        0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c, 0x13121110, 0x17161514, 0x1b1a1918,
        0x1f1e1d1c,
    ];

    let nonce = [0x09000000, 0x4a000000, 0x00000000];

    let counter = 0x00000001;
    let expected_result = [
        0xe4e7f110, 0x15593bd1, 0x1fdd0f50, 0xc47120a3, 0xc7f4d1c7, 0x0368c033, 0x9aaa2204,
        0x4e6cd4c3, 0x466482d2, 0x09aa9f07, 0x05d7c214, 0xa2028bd9, 0xd19c12b5, 0xb94e16de,
        0xe883d0cb, 0x4e3c50a2,
    ];

    let result = chacha20_block(key, nonce, counter);
    for i in 0..16 {
        assert(result[i] == expected_result[i]);
    }
}

#[test]
fn test_chacha20_setup_16_block() {
    // Test case from RCF https://www.rfc-editor.org/rfc/rfc7539.html#section-2.4.2
    let key = [
        0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c, 0x13121110, 0x17161514, 0x1b1a1918,
        0x1f1e1d1c,
    ];

    let nonce: [u32; 3] = [0x00000000, 0x4a000000, 0x00000000];

    let counter: u32 = 1;

    // "Ladies and Gentlemen of the class of '99: If I could offer you o"
    let plaintext: [Field; 64] = [
        0x4c, 0x61, 0x64, 0x69, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x47, 0x65, 0x6e, 0x74,
        0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c,
        0x61, 0x73, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x27, 0x39, 0x39, 0x3a, 0x20, 0x49, 0x66, 0x20,
        0x49, 0x20, 0x63, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x20, 0x79,
        0x6f, 0x75, 0x20, 0x6f,
    ];

    let expected_ciphertext: [u8; 64] = [
        0x6e, 0x2e, 0x35, 0x9a, 0x25, 0x68, 0xf9, 0x80, 0x41, 0xba, 0x07, 0x28, 0xdd, 0x0d, 0x69,
        0x81, 0xe9, 0x7e, 0x7a, 0xec, 0x1d, 0x43, 0x60, 0xc2, 0x0a, 0x27, 0xaf, 0xcc, 0xfd, 0x9f,
        0xae, 0x0b, 0xf9, 0x1b, 0x65, 0xc5, 0x52, 0x47, 0x33, 0xab, 0x8f, 0x59, 0x3d, 0xab, 0xcd,
        0x62, 0xb3, 0x57, 0x16, 0x39, 0xd6, 0x24, 0xe6, 0x51, 0x52, 0xab, 0x8f, 0x53, 0x0c, 0x35,
        0x9f, 0x08, 0x61, 0xd8,
    ];

    let ciphertext_digest = data_hasher(expected_ciphertext, Field::default());

    // Initialize Setup state
    let setup = SetupState { key, nonce, counter, plaintext, ciphertext_digest };

    // Initialize step_in
    let mut step_in: [Field; 11] = [Field::default(); 11];
    step_in[1] = Field::from(1); // ciphertext_digest_pow initializes as 1

    // Run verification
    let step_out: [Field; 11] = setup.verify(step_in);

    // Calculate expected output
    let plaintext_digest =
        polynomial_digest(plaintext.map(|x| Field::from(x)), ciphertext_digest, 1);

    let expected_output = plaintext_digest - ciphertext_digest;

    // Verify results
    assert(step_out[0] == expected_output);
}

#[test]
fn test_chacha20_setup_padded_text() {
    // Test case from RCF https://www.rfc-editor.org/rfc/rfc7539.html#section-2.4.2
    let key = [
        0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c, 0x13121110, 0x17161514, 0x1b1a1918,
        0x1f1e1d1c,
    ];
    let nonce: [u32; 3] = [0x00000000, 0x4a000000, 0x00000000];
    let counter: u32 = 1;
    // "Ladies and Gentlemen of the class of '99: If I could offer you only one tip "
    let plaintext: [Field; 76] = [
        0x4c, 0x61, 0x64, 0x69, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x47, 0x65, 0x6e, 0x74,
        0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c,
        0x61, 0x73, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x27, 0x39, 0x39, 0x3a, 0x20, 0x49, 0x66, 0x20,
        0x49, 0x20, 0x63, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x20, 0x79,
        0x6f, 0x75, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x74, 0x69, 0x70,
        0x20,
    ]; // 76 bytes

    let expected_ciphertext: [u8; 76] = [
        0x6e, 0x2e, 0x35, 0x9a, 0x25, 0x68, 0xf9, 0x80, 0x41, 0xba, 0x07, 0x28, 0xdd, 0x0d, 0x69,
        0x81, 0xe9, 0x7e, 0x7a, 0xec, 0x1d, 0x43, 0x60, 0xc2, 0x0a, 0x27, 0xaf, 0xcc, 0xfd, 0x9f,
        0xae, 0x0b, 0xf9, 0x1b, 0x65, 0xc5, 0x52, 0x47, 0x33, 0xab, 0x8f, 0x59, 0x3d, 0xab, 0xcd,
        0x62, 0xb3, 0x57, 0x16, 0x39, 0xd6, 0x24, 0xe6, 0x51, 0x52, 0xab, 0x8f, 0x53, 0x0c, 0x35,
        0x9f, 0x08, 0x61, 0xd8, 0x07, 0xca, 0x0d, 0xbf, 0x50, 0x0d, 0x6a, 0x61, 0x56, 0xa3, 0x8e,
        0x08,
    ];

    let totalLength = 128;
    let mut paddedPlaintextByte = [Field::default(); 128];
    for i in 0..totalLength {
        if i < plaintext.len() {
            paddedPlaintextByte[i] = plaintext[i];
        } else {
            paddedPlaintextByte[i] = PADDING_VALUE;
        }
    }
    let ciphertext_digest = data_hasher(expected_ciphertext, Field::from(0));

    // Initialize Setup state
    let setup =
        SetupState { key, nonce, counter, plaintext: paddedPlaintextByte, ciphertext_digest };

    // Initialize step_in
    let mut step_in: [Field; 11] = [Field::default(); 11];
    step_in[1] = Field::from(1); // ciphertext_digest_pow initializes as 1

    // Run verification
    let step_out: [Field; 11] = setup.verify(step_in);

    // Calculate expected output
    let plaintext_digest =
        polynomial_digest(plaintext.map(|x| Field::from(x)), ciphertext_digest, 1);

    let expected_output = plaintext_digest - ciphertext_digest;

    // Verify results

    assert(step_out[0] == expected_output);
}

#[test]
fn test_chacha20_setup_padded_text_split() {
    // Test case from RCF https://www.rfc-editor.org/rfc/rfc7539.html#section-2.4.2
    let key = [
        0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c, 0x13121110, 0x17161514, 0x1b1a1918,
        0x1f1e1d1c,
    ];
    let nonce: [u32; 3] = [0x00000000, 0x4a000000, 0x00000000];
    let counter: u32 = 1;
    // "Ladies and Gentlemen of the class of '99: If I could offer you only one tip "
    let plaintext: [Field; 76] = [
        0x4c, 0x61, 0x64, 0x69, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x47, 0x65, 0x6e, 0x74,
        0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c,
        0x61, 0x73, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x27, 0x39, 0x39, 0x3a, 0x20, 0x49, 0x66, 0x20,
        0x49, 0x20, 0x63, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x20, 0x79,
        0x6f, 0x75, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x74, 0x69, 0x70,
        0x20,
    ]; // 76 bytes

    let expected_ciphertext: [u8; 76] = [
        0x6e, 0x2e, 0x35, 0x9a, 0x25, 0x68, 0xf9, 0x80, 0x41, 0xba, 0x07, 0x28, 0xdd, 0x0d, 0x69,
        0x81, 0xe9, 0x7e, 0x7a, 0xec, 0x1d, 0x43, 0x60, 0xc2, 0x0a, 0x27, 0xaf, 0xcc, 0xfd, 0x9f,
        0xae, 0x0b, 0xf9, 0x1b, 0x65, 0xc5, 0x52, 0x47, 0x33, 0xab, 0x8f, 0x59, 0x3d, 0xab, 0xcd,
        0x62, 0xb3, 0x57, 0x16, 0x39, 0xd6, 0x24, 0xe6, 0x51, 0x52, 0xab, 0x8f, 0x53, 0x0c, 0x35,
        0x9f, 0x08, 0x61, 0xd8, 0x07, 0xca, 0x0d, 0xbf, 0x50, 0x0d, 0x6a, 0x61, 0x56, 0xa3, 0x8e,
        0x08,
    ];

    let totalLength = 128;
    let mut paddedPlaintextByte = [Field::default(); 128];
    for i in 0..totalLength {
        if i < plaintext.len() {
            paddedPlaintextByte[i] = plaintext[i];
        } else {
            paddedPlaintextByte[i] = PADDING_VALUE;
        }
    }
    let ciphertext_digest = data_hasher(expected_ciphertext, Field::from(0));

    let mut plaintext_1 = [Field::default(); 64];
    let mut plaintext_2 = [Field::default(); 64];
    for i in 0..64 {
        plaintext_1[i] = paddedPlaintextByte[i];
    }

    for i in 0..64 {
        plaintext_2[i] = paddedPlaintextByte[64 + i];
    }
    let mut step_in: [Field; 11] = [Field::default(); 11];
    step_in[1] = Field::from(1); // ciphertext_digest_pow initializes as 1

    // Setup1
    let mut setup = SetupState { key, nonce, counter, plaintext: plaintext_1, ciphertext_digest };
    let step_out: [Field; 11] = setup.verify(step_in);

    // Setup2
    setup =
        SetupState { key, nonce, counter: counter + 1, plaintext: plaintext_2, ciphertext_digest };

    step_in = step_out;
    let step_out_2: [Field; 11] = setup.verify(step_in);

    // Calculate expected output
    let plaintext_digest =
        polynomial_digest(plaintext.map(|x| Field::from(x)), ciphertext_digest, 1);
    let expected_output = plaintext_digest - ciphertext_digest;

    assert(step_out_2[0] == expected_output);
    assert(step_out_2[1] == ciphertext_digest.pow_32(plaintext.len() as Field));
    assert(step_out_2[10] == ciphertext_digest);
}
